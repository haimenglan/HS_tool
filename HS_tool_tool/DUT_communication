#! /usr/bin/env python3
#! /Library/Frameworks/Python.framework/Versions/3.7/bin/python3.7
import os
import sys
import time

import threading
import csv
import time
from time import sleep
import re

import serial  # 导入模块
from serial.tools import list_ports

import xlwt
import xlrd
#from haimeng_xlwt import Haimeng_xlwt

class Haimeng_xlwt:
    def __init__(self,file_path=""):
        self.xls_file_path = file_path
        self.xls_book = xlwt.Workbook()
        self.blank_style = self.set_blank_style()

        self.gray_title_style = self.set_style('Helvetica', 250, font_colour=0, font_bold=True, pattern_colour=22)
        self.station_style = self.set_style('Helvetica', 250, font_colour=0, font_bold=True, pattern_colour=67)

        self.normal_style = self.set_style('Helvetica', 220, font_colour=0, font_bold=False,pattern_colour=1)
        self.normal_no_wrap_style = self.set_style('Helvetica', 220, font_colour=0, font_bold=False,pattern_colour=1,is_wrap=0)
        self.persentage_style = self.set_style('Helvetica', 220, font_colour=0, font_bold=False,pattern_colour=1,is_persentage=True)
        self.yellow_style = self.set_style('Helvetica', 220, font_colour=0, font_bold=False,pattern_colour=5)
        self.cyan_style = self.set_style('Helvetica', 220, font_colour=0, font_bold=False, pattern_colour=7)
        self.green_style = self.set_style('Helvetica', 220, font_colour=0, font_bold=False, pattern_colour=3)
        self.orange_style = self.set_style('Helvetica', 220, font_colour=0, font_bold=False,pattern_colour=52)
        self.red_style = self.set_style('Helvetica', 220, font_colour=0, pattern_colour=2, font_bold=False)
        self.blue_style = self.set_style('Helvetica', 220, font_colour=1, pattern_colour=4, font_bold=False)

        self.red_font_style = self.set_style('Helvetica', 220, font_colour=2, font_bold=False,pattern_colour=1)
        self.yellow_font_style = self.set_style('Helvetica', 220, font_colour=52, font_bold=False,pattern_colour=1)

    def set_blank(self,sheet,row_start,row_end,column_start,column_end):
        #print(row_start,row_end,column_start,column_end)
        for i in range(100):
            for j in range(100):
                if i in range(row_start,row_end) and \
                    j in range(column_start,column_end):
                    continue
                else:
                    sheet.write(i,j,"",self.blank_style)

    def set_blank_style(self,pattern_colour=1):
        style = xlwt.XFStyle()  # 新建风格
        pattern = xlwt.Pattern()
        pattern.pattern = xlwt.Pattern.SOLID_PATTERN  # 设置填充模式为全部填充
        pattern.pattern_fore_colour = pattern_colour  # 设置填充颜色为蓝色

        style.pattern = pattern
        return style

    def write_line(self,sheet,row,column,line,style,persent_column=None):
        new_column = column
        for each_value in line:
            if len(str(each_value))>=32767:
                print("can't write too long string: ",str(each_value))
                each_value = each_value[:32767]
            if new_column==0 and style!=self.gray_title_style and each_value!="":
                sheet.write(row,new_column,each_value,self.station_style)
            else:
                if persent_column is not None:
                    if new_column in persent_column:
                        sheet.write(row,new_column,each_value,self.persentage_style)
                    else:
                        sheet.write(row,new_column,each_value,style)
                else:
                    sheet.write(row,new_column,each_value,style)
            new_column += 1

    def set_style(self,font_name, font_height, font_colour=1, font_bold=False,pattern_colour=1,is_wrap=1,is_persentage=False):
        style = xlwt.XFStyle()  # 新建风格
        font = xlwt.Font()  # 新建字体
        font.name = font_name
        font.bold = font_bold  # 是否加粗
        font.colour_index = font_colour
        font.height = font_height
        if is_persentage:
            font.num_format_str = "0.00%"

        pattern = xlwt.Pattern()
        pattern.pattern = xlwt.Pattern.SOLID_PATTERN  # 设置填充模式为全部填充
        pattern.pattern_fore_colour = pattern_colour  # 设置填充颜色为蓝色

        alignment = xlwt.Alignment()  # 创建alignment对齐方式
        alignment.horz = xlwt.Alignment.HORZ_LEFT
        alignment.vert = xlwt.Alignment.VERT_CENTER

        borders = xlwt.Borders()
        borders.left = xlwt.Borders.THIN
        borders.right = xlwt.Borders.THIN
        borders.top = xlwt.Borders.THIN
        borders.bottom = xlwt.Borders.THIN
        borders.left_colour = 0x00  # 设置左边框线条颜色
        borders.right_colour = 0x00
        borders.top_colour = 0x00
        borders.bottom_colour = 0x00

        style.borders = borders
        style.alignment = alignment
        style.font = font
        style.pattern = pattern
        style.alignment.wrap = is_wrap #是否换行
        return style



def change_path(path):
    while " " == path[-1]:
        path = path[:-1]
    while "\\" in path:
        path = path.replace("\\", "")
    return path

def mount_usbfs():
    os.system("killall -9 usbfs")
    os.system("killall -9 nanokdp")
    path = sys.path[0]
    if not os.path.exists(os.path.join(path, "usbfs")):
        os.mkdir(os.path.join(path, "usbfs"))
    os.system("usbfs -f %s" % (os.path.join(path, "usbfs")))


class My_serial:
    def __init__(self, dut_bps, time_out):
        self.dut_bps = dut_bps
        self.time_out = time_out
        self.port_name = ""
        self.suspend_manully_read = False
        self.quit_manully_read = False
        self.stop_auto_run = False

        self.usbfs_thread = threading.Thread(target=mount_usbfs)
        #self.usbfs_thread.setDaemon(True)
        self.usbfs_thread.start()
        sleep(0.1)
        self.reflesh_port()

    def print_help(self):
        print("\033[1;36mRead me:\033[0m")
        print(
            "\033[1;32minput 'q': quit/back\ninput 'superos: change diags to os\ninput 'superdiags': change os to diags\033[0m")

    def reflesh_port(self):
        self.print_help()
        self.port_list = list(list_ports.comports())
        if len(self.port_list) <= 0:
            print("\033[1;31mno port found(找不到任何串口设备)\033[0m")
        else:
            print("\033[1;36musb port list: \033[0m")
            i = 0
            for each_port in self.port_list:
                print('(' + str(i) + ')  ' + str(each_port))
                i += 1
            print('(' + str(i) + ')  ' + "reflesh port(刷新端口)")
            self.select_port()

    def select_port(self):
        select_num = input('\033[1;36mselect a port to open: \033[0m ')
        user_select_port_re = re.search(r'\d+', select_num)  # 匹配数字
        if user_select_port_re != None:
            if int(user_select_port_re.group()) == len(self.port_list):
                self.reflesh_port()
            elif int(user_select_port_re.group()) < len(self.port_list):
                original_port_name = self.port_list[int(user_select_port_re.group())]  # 原始端口名
                port_name_re = re.search(r'(/dev/cu.+) - ', str(original_port_name))  # 匹配端口名
                self.port_name = port_name_re.group(1)  # 最终端口名
                print("\033[1;36myou selected port: \033[0m" + self.port_name)
                # ----------------触发打开端口名--------------------------------
                self.open_port()
            else:
                print("\033[1;31minput error, must include a number...input again\033[0m")
                self.reflesh_port()
        else:
            print("\033[1;31minput error, must include a number...input again\033[0m")
            self.reflesh_port()

    def open_port(self):
        self.retry_open_times = 0
        self.ser = serial.Serial(self.port_name, self.dut_bps, timeout=self.time_out)
        if self.ser.isOpen():  # check open status
            print("open success")
            self.select_function()
        else:
            if self.retry_open_times < 20:
                self.retry_open_times += 1
                self.open_port()
            else:  # 尝试打开20+次都失败，要求重新选择
                print("open port  failed!")
                self.reflesh_port()

    def select_function(self):
        print("\n1)Manually send command(默认手动模式)\n2)Auto run diags commnand(自动模式)\n3)reflesh port(刷新端口)")
        function_select = str(input("\033[1;36mselect mode: \033[0m"))
        user_select_re = re.search(r'\d+', function_select)  # 匹配数字
        if user_select_re != None:
            if int(user_select_re.group()) == 1:
                self.quit_manully_read = False
                print("this is mannually mode")
                self.manually_read_thread = threading.Thread(target=self.read_manual_mode_data)
                #self.manually_read_thread.setDaemon(True)
                self.manually_read_thread.start()
                self.manually_sent_command()
            elif int(user_select_re.group()) == 2:
                print("this is auto mode")
                self.quit_manully_read = True
                self.stop_auto_run = False
                all_file_path = input("\033[1;36minput csv/xls command file(use ',' to separate them if you have more than one file): \033[0m").split(",")
                self.auto_mode_thread = threading.Thread(target=self.start_auto_mode, args=(all_file_path,))
                #self.auto_mode_thread.setDaemon(True)
                self.auto_mode_thread.start()
                self.auto_sent_command()
            elif int(user_select_re.group()) == 3:
                self.reflesh_port()
            else:
                print("\033[1;31minput error!\033[0m")
                self.select_function()
        else:
            print("\033[1;31minput error!\033[0m")
            self.select_function()

    def login_os(self, respond):
        if "login:" in str(respond):
            self.ser.write('root\n'.encode("utf-8"))
            self.ser.flush()
            sleep(0.05)
            self.ser.write('alpine\n'.encode("utf-8"))
            self.ser.flush()

    def print_data(self, recv_data):
        if ":-)" in recv_data or "root#" in recv_data:
            if "\n" in recv_data:
                search_key = re.search(r"\n.*$", recv_data)
                print("%s\033[1;33m%s\033[0m" % (recv_data[:search_key.start()], recv_data[search_key.start():]),
                      end="")
            else:
                print("\033[1;33m%s\033[0m" % (recv_data), end="")
        else:
            print(recv_data, end="")
        sleep(0.01)

    def reconnect_port(self):
        self.ser.close()
        print("\033[1;31m设备连接不稳定,尝试重连\033[0m")
        self.ser = serial.Serial(self.port_name, self.dut_bps, timeout=self.time_out)
        print("\033[1;32m重新连接成功...\033[0m")  # 处理Device not configured异常

    def recv_port_data(self):
        re_connect_time = 0
        recv_data = ""
        while re_connect_time < 20:
            try:
                recv_data = self.ser.read(self.ser.in_waiting)
                break
            except Exception as e:
                if ('Device not configured' in str(e) or "argument must be an int" in str(e)):
                    try:
                        self.reconnect_port()
                        break
                    except Exception as e2:
                        re_connect_time += 1
                        if re_connect_time == 19:
                            print("\033[1;31m重新连接失败\033[0m", str(e2))
                            return None
                elif "device reports readiness to read but returned no data" in str(e):
                    re_connect_time += 1
                    self.quit_manully_read = True
                else:
                    print("\033[1;31m%s\033[0m"%(str(e)))
                    re_connect_time += 1
        try:
            recv_data = recv_data.decode("utf-8")  # 逐个获取原始 输出字符串
        except:
            try:
                recv_data = recv_data.decode("utf-8-sig")
            except Exception as e:
                pass
                #print("\033[1;31m数据解码异常\033[0m", str(e))
        return str(recv_data)

    def change_str(self, string):
        # ---移除控制终端颜色的字符
        while ("\033[" in string):
            search_key = re.search('\033(\[\d{1,3}m){1,3}', string)
            if search_key != None:
                string = string.replace(search_key.group(), '')
            else:
                break
        return string

    def read_all_data(self):
        auto_recv_data = ""
        current_time = time.time()
        pass_time = time.time() - current_time
        key_list = [r":-\) $", r"root# "]
        search_end_key = None
        while search_end_key is None and pass_time < 100:
            for each_key in key_list:
                search_end_key = re.search(each_key, auto_recv_data)
                if search_end_key is not None:
                    break
            pass_time = time.time() - current_time
            recv_data = self.recv_port_data()
            if recv_data is None:
                self.reflesh_port()
                break

            self.print_data(recv_data)
            auto_recv_data += str(recv_data)
            recv_data = ""
        auto_recv_data = self.change_str(auto_recv_data)
        return auto_recv_data

    def read_manual_mode_data(self):
        while True:
            sleep(0.001)  # 防止界面程序因为多线程卡顿
            if self.quit_manully_read:
                break
            if not self.suspend_manully_read:
                recv_data = self.recv_port_data()
                if recv_data is None:
                    self.reflesh_port()
                    break
                self.login_os(recv_data)
                self.print_data(recv_data)

    def write_ser(self, command):
        try:
            sent_command = str(command)
            while len(sent_command) > 100:
                self.ser.write(sent_command[:100].encode())
                current_time = time.time()
                while self.ser.out_waiting and (time.time() - current_time) < 5:
                    time.sleep(0.05)
                sent_command = sent_command[100:]
            if len(sent_command) != 0:
                current_time = time.time()
                self.ser.write(sent_command.encode())
                while self.ser.out_waiting and (time.time() - current_time) < 5:
                    time.sleep(0.05)
            self.ser.write("\n".encode())
        except Exception as e:
            print("\033[1;31m写入异常:\033[0m", e)

    def check_current_mode(self):
        current_mode = ""
        self.write_ser("")
        recv_data = self.read_all_data()
        if ":-)" in recv_data:
            current_mode = "diags"
        elif "root#" in recv_data:
            current_mode = "os"
        elif "]" in recv_data:
            current_mode = "recovery"
        return current_mode

    def change_to_diags_os(self, command):
        os_to_diags_command_list = ["nvram boot-command=diags", "nvram auto-boot=true", "reboot"]
        diags_to_os_command_list = ["nvram --set boot-command 'fasboot'",
                                    "nvram --set auto-boot 'true'", "nvram --save", "reset"]
        current_mode = self.check_current_mode()
        if command == "superdiags":
            if current_mode == "diags":
                print("\033[1;31myou already in diags\033[0m")
            elif current_mode == "os":
                for each_command in os_to_diags_command_list:
                    self.write_ser(each_command)
        elif command == "superos":
            if current_mode == "os":
                print("\033[1;31myou already in os\033[0m")
            elif current_mode == "diags":
                for each_command in diags_to_os_command_list:
                    self.write_ser(each_command)

    def fast_command(self, command):
        if command == "superdiags" or command == "superos":
            self.change_to_diags_os(command)
        elif command == "dl" or command == "DL":
            self.write_ser('device -k gasgauge -p\n')
        elif command == 'gj' or command == 'GJ':
            self.write_ser('shutdown\n')
        else:
            self.write_ser(command)

    def manually_sent_command(self):
        while True:
            command = str(input(""))
            if command == "q":
                self.quit_manully_read = True
                break
            self.suspend_manully_read = True
            self.fast_command(command)
            self.suspend_manully_read = False
        self.select_function()

    def read_file(self, file_path):
        file_command_list = []
        if ".csv" in file_path:
            with open(file_path) as csvf:
                read_csv = csv.reader(csvf)
                read_csv = list(read_csv)
                # print(read_csv)
                for each_line in read_csv:
                    if each_line != []:
                        for each_command in each_line:
                            if "\ufeff" in each_command:
                                each_command = each_command.replace("\ufeff", "")
                            file_command_list.append(each_command)
        elif ".xls" in file_path or "xlsx" in file_path:
            xls_book = xlrd.open_workbook(file_path)
            for each_table in range(1):
                table = xls_book.sheets()[each_table]
                file_command_list = table.col_values(0, 0)  # column=0, start_row=0
        return file_command_list

    def auto_sent_command(self):
        while True:
            if self.stop_auto_run:
                self.select_function()
                break
            command = str(input(""))
            if command == "q":
                self.stop_auto_run = True
                break

    def start_auto_mode(self,all_file_path):
        print("start auto")
        try:
            for each_file in all_file_path:
                file_path = change_path(each_file)
                file_command_list = self.read_file(file_path)
                auto_result_list = []
                for each_command in file_command_list:
                    if self.stop_auto_run:
                        break
                    if each_command != "":
                        self.write_ser(each_command)
                        auto_recv_data = self.read_all_data()
                        auto_result_list.append(auto_recv_data)
                print("\033[1;32m\nfile '%s' running finished! %d command have been sent,\033[0m" % (
                    file_path, len(auto_result_list)),end="")
                self.save_xls(auto_result_list, file_path)
        except Exception as e:
            print(str(e))
        if self.stop_auto_run:
            self.select_function()
        else:
            print("\033[1;36mpress any key to continue\033[0m")
            self.stop_auto_run = True

    def save_xls(self, auto_result_list, file_path):
        #print(auto_result_list)
        path = os.path.dirname(file_path)
        file_name = os.path.basename(file_path)
        file_name = os.path.splitext(file_name)[0]
        save_path = os.path.join(path, file_name + "_result.xls")
        result_num = 0

        haimeng_xlwt = Haimeng_xlwt(save_path)
        sheet = haimeng_xlwt.xls_book.add_sheet(file_name)
        title = ["command", "result", "result2"]
        haimeng_xlwt.write_line(sheet, 0, 0, title, haimeng_xlwt.gray_title_style)
        sheet.col(0).width,sheet.col(1).width,sheet.col(2).width = 10000,20000,20000
        row = 1
        for each_result in auto_result_list:
            result_num += 1
            command_re = re.search(r"^(.+)\n", each_result)
            result_start = 0
            if command_re != None:
                result_start = command_re.end()
                command = each_result[:command_re.end() - 1]
            else:
                command = each_result
            respond_re = re.search(r"\r*\n*\[.+\].:-\)", each_result)
            if respond_re != None:
                result = each_result[result_start:respond_re.start()]
            else:
                respond_re = re.search(r"\r*\n*.*:~ root#", each_result)
                if respond_re != None:
                    result = each_result[result_start:respond_re.start()]
                else:
                    result = each_result
            sheet.write(row, 0, command, haimeng_xlwt.normal_style)

            result_column = 1
            while len(str(result))>32760:
                if 'WARNING' in result and 'ERROR' not in result and "error" not in result:
                    sheet.write(row,result_column,result[:32760],haimeng_xlwt.yellow_font_style)
                elif 'ERROR' in result or "error" in result:
                    sheet.write(row,result_column,result[:32760],haimeng_xlwt.red_font_style)
                else:
                    sheet.write(row,result_column,result[:32760],haimeng_xlwt.normal_style)
                result = result[32760:]
                result_column += 1
            if len(str(result))>0:
                if 'WARNING' in result and 'ERROR' not in result and "error" not in result:
                    sheet.write(row,result_column,result,haimeng_xlwt.yellow_font_style)
                elif 'ERROR' in result or "error" in result:
                    sheet.write(row,result_column,result,haimeng_xlwt.red_font_style)
                else:
                    sheet.write(row,result_column,result,haimeng_xlwt.normal_style)
            row+=1
            
        haimeng_xlwt.xls_book.save(save_path)
        print("\033[1;32m%d command been read.\033[0m" % (result_num))
        print("\033[1;32mresult have save at %s\033[0m" % (save_path))


if __name__ == "__main__":
    dut_sent_command = My_serial(115200, None)